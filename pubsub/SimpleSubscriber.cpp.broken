#include "SimpleSubscriber.h"
#include <iostream>
#include <cstring>

SimpleSubscriber::SimpleSubscriber(struct event_base* shared_event_base)
    : _libevent_base(shared_event_base) {
    _protocol = new PubSubTopicProtocol();
    _subscription_mask = 0;
    _current_status = CLIENT_OFFLINE;
    _socket_handler = nullptr;
    _sequence_storage = nullptr;
    _publisher_sequence_record = nullptr;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

SimpleSubscriber::~SimpleSubscriber() {
    if (_socket_handler) {
        delete _socket_handler;
    }
    delete _protocol;
    delete _publisher_sequence_record;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

bool SimpleSubscriber::change_status(ClientStatus status) {
    _current_status = status;
    return true;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::set_address(SocketType socket_type, std::string address, int port) {
    _socket_type = socket_type;
    _address = address;
    _port = port;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::set_client_info(uint32_t client_id, const std::string& client_name) {
    _subscriber_id = client_id;
    _subscriber_name = client_name;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

bool SimpleSubscriber::connect() {
    std::cout << "Connecting to " << (_socket_type == UNIX_SOCKET ? "Unix socket" : "TCP socket") << ": " << _address << std::endl;
    
    if (_socket_handler) {
        delete _socket_handler;
        _socket_handler = nullptr;
    }
    
    std::string socket_type_str;
    if (_socket_type == UNIX_SOCKET) {
        socket_type_str = "unix_domain_socket";
    } else if (_socket_type == TCP_SOCKET) {
        socket_type_str = "tcp_socket";
    } else {
        std::cerr << "Unknown socket type" << std::endl;
        return false;
    }
    
    // EventBase wrapper 생성
    _socket_handler = createEventBase(socket_type_str, _libevent_base, false);
    if (!_socket_handler) {
        std::cerr << "Failed to create socket handler" << std::endl;
        return false;
    }
    
    // Protocol 및 콜백 설정
    _socket_handler->setProtocol(_protocol);
    _socket_handler->setReadCallback([this](char *data, int size) {
        handle_incomming_messages(data, size);
    });
    _socket_handler->setConnectCallback([this](char *data, int size) {
        handle_connected(data, size);
    });
    _socket_handler->setDisconnectCallback([this](char *data, int size) {
        handle_disconnected(data, size);
    });
    _socket_handler->setErrorCallback([this](char *data, int size) {
        handle_error(data, size);
    });
    
    // 서버에 연결 시도
    try {
        _socket_handler->connect(_address);
    } catch (const std::exception& e) {
        std::cerr << "Failed to connect: " << e.what() << std::endl;
        return false;
    }
    return true;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}


void SimpleSubscriber::set_subscription_mask(uint32_t mask) {
    _subscription_mask = mask;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::set_topic_callback(TopicDataCallback callback) {
    _topic_callback = callback;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::handle_connected(char* data, int size) {
    std::cout << "Connected to publisher" << std::endl;
    change_status(CLIENT_CONNECTED);
    send_subscription_request();
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::handle_disconnected(char* data, int size) {
    std::cout << "Disconnected from publisher" << std::endl;
    change_status(CLIENT_OFFLINE);
    try_reconnect();
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::handle_error(char* data, int size) {
    std::cout << "Error occurred, will reconnect in 1 second..." << std::endl;
    change_status(CLIENT_OFFLINE);
    try_reconnect();
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            self->connect();
        }, this, &delay);
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::handle_incomming_messages(char* data, int size) {
    uint32_t magic = 0;
    memcpy(&magic, data, sizeof(uint32_t));
    std::cout << "Received message - magic: 0x" << std::hex << magic << std::dec << " (" << magic << "), size: " << size << std::endl;
    std::cout << "Expected magics - TOPIC_MSG: 0x" << std::hex << MAGIC_TOPIC_MSG << ", SUB_OK: 0x" << MAGIC_SUB_OK << std::dec << std::endl;
    
    switch(magic) {
        case MAGIC_TOPIC_MSG:
            std::cout << "Handling TOPIC_MSG" << std::endl;
            handle_topic_message(*(TopicMessage*)data);
            break;
        case MAGIC_SUB_OK:
            std::cout << "Handling SUBSCRIPTION_RESPONSE" << std::endl;
            handle_subscription_response(*(SubscriptionResponse*)data);
            break;
        case MAGIC_RECOVERY_RES:
            std::cout << "Handling RECOVERY_RESPONSE" << std::endl;
            handle_recovery_response(*(RecoveryResponse*)data);
            break;
        case MAGIC_RECOVERY_CMP:
            std::cout << "Handling RECOVERY_COMPLETE" << std::endl;
            handle_recovery_complete(*(RecoveryComplete*)data);
            break;
        default:
            std::cout << "Unknown magic: 0x" << std::hex << magic << std::dec << " (" << magic << ")" << std::endl;
            // Print first 16 bytes of data for debugging
            std::cout << "First 16 bytes: ";
            for (int i = 0; i < std::min(size, 16); i++) {
                printf("%02x ", (unsigned char)data[i]);
            }
            std::cout << std::endl;
            break;
    }
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::handle_topic_message(const TopicMessage& topic_message) {
    std::cout << "Received topic message - topic: " << topic_message.topic 
              << ", global_seq: " << topic_message.global_seq 
              << ", data_size: " << topic_message.data_size << std::endl;
    
    // callback 함수 호출
    if (_topic_callback) {
        _topic_callback(topic_message.topic, topic_message.data, topic_message.data_size);
    }
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::handle_subscription_response(const SubscriptionResponse& subscription_response) {
    std::cout << "Subscription response - result: " << subscription_response.result << std::endl;
    
    if (subscription_response.result == 0) {
        change_status(CLIENT_ONLINE);
    }
    send_recovery_request();
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::handle_recovery_response(const RecoveryResponse& recovery_response) {
    std::cout << "Recovery response - result: " << recovery_response.result << std::endl;
    change_status(CLIENT_RECOVERING);
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

void SimpleSubscriber::handle_recovery_complete(const RecoveryComplete& recovery_complete) {
    std::cout << "Recovery complete - total_sent: " << recovery_complete.total_sent << std::endl;
    change_status(CLIENT_ONLINE);
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

bool SimpleSubscriber::send_subscription_request() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    SubscriptionRequest subscription_request;
    subscription_request.magic = MAGIC_SUBSCRIBE;
    subscription_request.client_id = 1001; // default client ID
    subscription_request.topic_mask = _subscription_mask;
    subscription_request.last_seq = 0; // start from beginning
    strncpy(subscription_request.client_name, "subscriber", sizeof(subscription_request.client_name) - 1);
    
    if (_socket_handler) {
        std::cout << "Sending subscription request" << std::endl;
        _socket_handler->trySend(&subscription_request, sizeof(subscription_request));
    }
    return true;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}

bool SimpleSubscriber::send_recovery_request() {
    RecoveryRequest recovery_request;
    recovery_request.magic = MAGIC_RECOVERY_REQ;
    recovery_request.client_id = 1001;
    recovery_request.topic_mask = _subscription_mask;
    recovery_request.last_seq = 0;
    
    if (_socket_handler) {
        _socket_handler->trySend(&recovery_request, sizeof(recovery_request));
    }
    return true;
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}


void SimpleSubscriber::stop() {
    _current_status = CLIENT_OFFLINE;
    if (_socket_handler) {
        delete _socket_handler;
        _socket_handler = nullptr;
    }
}

void SimpleSubscriber::try_reconnect() {
    // Create a timer event for delayed reconnection
    struct timeval delay = {1, 0}; // 1 second delay
    event_base_once(_libevent_base, -1, EV_TIMEOUT,
        [](evutil_socket_t fd, short event, void *arg) {
            SimpleSubscriber* self = static_cast<SimpleSubscriber*>(arg);
            std::cout << "Attempting reconnection..." << std::endl;
            if (!self->connect()) {
                std::cout << "Reconnection failed, will retry in 1 second..." << std::endl;
                self->try_reconnect(); // 재귀적으로 재연결 시도
            }
        }, this, &delay);
}
