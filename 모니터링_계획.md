# asdf Pub/Sub 시스템 모니터링 계획

## 개요
SimplePublisherV2/SimpleSubscriber 시스템에 대한 종합적인 모니터링 시스템 설계 및 구현 계획

## 현재 상태
- Publisher: 기본적인 상태만 확인 가능 (`get_client_count()`, `get_current_sequence()`, `get_publisher_date()`)
- Subscriber: 연결 상태만 로그로 출력
- 시스템 전체 상태 파악 어려움

## 1. 모니터링 데이터 구조

### 1.1 시스템 통합 모니터링 레코드
```cpp
struct SystemMonitoringRecord {
    uint64_t timestamp;
    char system_name[64];              // 시스템 식별자

    // Publisher 전체 상태
    struct PublisherMonitoringData {
        char publisher_name[64];
        uint32_t publisher_id;
        uint32_t current_global_seq;
        uint32_t topic1_seq, topic2_seq, misc_seq;
        uint32_t active_connections;
        uint32_t total_messages_sent;
        uint64_t uptime_seconds;
        uint32_t recovery_threads_count;
        uint32_t pending_recovery_tasks;
        float cpu_usage_percent;
        uint64_t memory_usage_bytes;
    } publisher_stats;

    // 전체 Subscriber 상태 요약
    struct SubscribersSummary {
        uint32_t total_subscribers;
        uint32_t online_subscribers;
        uint32_t recovering_subscribers;
        uint32_t offline_subscribers;
        uint32_t max_sequence_lag;      // 가장 뒤처진 subscriber의 lag
        uint32_t avg_sequence_lag;      // 평균 lag
        uint64_t total_messages_delivered;
    } subscribers_summary;

    char reserved[128];
};
```

### 1.2 개별 Subscriber 모니터링 데이터
```cpp
struct SubscriberMonitoringData {
    uint32_t client_id;
    char client_name[64];
    char publisher_name[64];
    ClientStatus status;
    uint32_t topic_mask;
    uint32_t last_received_seq;
    uint32_t sequence_lag;              // Publisher 현재 시퀀스와의 차이
    uint64_t connection_duration;       // 연결 지속 시간
    uint64_t messages_received;
    uint64_t recovery_count;            // 복구 요청 횟수
    uint64_t last_heartbeat;           // 마지막 하트비트
    float network_latency_ms;
    char last_error[128];
};
```

### 1.3 실시간 대시보드 데이터
```cpp
struct RealTimeDashboardData {
    // 실시간 처리량
    uint32_t messages_per_second;
    uint32_t bytes_per_second;

    // 지연시간 분포
    struct LatencyDistribution {
        float p50_ms, p95_ms, p99_ms, p999_ms;
    } latency_dist;

    // 시퀀스 상태
    uint32_t sequence_gaps_detected;
    uint32_t recovery_requests_pending;

    // 연결 상태
    std::map<ClientStatus, uint32_t> status_counts;

    // 에러/경고 카운트
    uint32_t error_count_last_minute;
    uint32_t warning_count_last_minute;
};
```

## 2. SequenceStorage 인터페이스 확장

### 2.1 모니터링 데이터 관리 메소드
```cpp
class SequenceStorage {
public:
    // 기존 메소드들...

    // 모니터링 데이터 관리
    virtual bool save_monitoring_data(const SystemMonitoringRecord& record) = 0;
    virtual bool load_latest_monitoring_data(const std::string& system_name,
                                           SystemMonitoringRecord* record) = 0;
    virtual bool save_subscriber_monitoring(const SubscriberMonitoringData& data) = 0;
    virtual bool load_all_subscriber_monitoring(const std::string& publisher_name,
                                              std::vector<SubscriberMonitoringData>& data) = 0;

    // 모니터링 쿼리 API
    virtual std::vector<SystemMonitoringRecord> get_monitoring_history(
        const std::string& system_name,
        uint64_t from_timestamp,
        uint64_t to_timestamp) = 0;

    virtual bool get_system_health_summary(const std::string& system_name,
                                         SystemHealthSummary* summary) = 0;
};
```

## 3. Publisher 모니터링 확장

### 3.1 SimplePublisherV2 모니터링 API
```cpp
class SimplePublisherV2 {
private:
    SystemMonitoringRecord _monitoring_record;
    std::chrono::steady_clock::time_point _start_time;
    std::atomic<uint64_t> _total_messages_sent{0};
    std::atomic<uint32_t> _pending_recovery_tasks{0};

public:
    // 모니터링 API
    SystemMonitoringRecord get_monitoring_snapshot();
    std::vector<SubscriberMonitoringData> get_all_subscribers_status();
    SubscriberMonitoringData get_subscriber_status(uint32_t client_id);

    // 알람/경고 조건 체크
    bool check_sequence_lag_alarm(uint32_t threshold = 1000);
    bool check_connection_health();
    std::vector<std::string> get_system_warnings();

    // 주기적 모니터링 업데이트
    void update_monitoring_data();
    void start_monitoring_thread(int interval_seconds = 30);
    void stop_monitoring_thread();
};
```

## 4. Subscriber 모니터링 확장

### 4.1 SimpleSubscriber 모니터링 API
```cpp
class SimpleSubscriber {
private:
    SubscriberMonitoringData _monitoring_data;
    std::chrono::steady_clock::time_point _connect_time;
    std::atomic<uint64_t> _messages_received{0};
    std::atomic<uint32_t> _recovery_count{0};

public:
    // 모니터링 API
    SubscriberMonitoringData get_monitoring_snapshot();
    uint32_t get_sequence_lag();
    bool is_healthy();

    // 하트비트 메커니즘
    void send_heartbeat();
    void handle_heartbeat_response();

    // 성능 메트릭
    float get_average_latency();
    uint64_t get_throughput_per_second();
};
```

## 5. 외부 모니터링 시스템 통합

### 5.1 모니터링 익스포터
```cpp
class MonitoringExporter {
public:
    virtual ~MonitoringExporter() = default;

    // Prometheus/Grafana 스타일 메트릭 익스포트
    virtual std::string export_prometheus_metrics() = 0;

    // JSON 형태 상태 익스포트
    virtual std::string export_json_status() = 0;

    // 시스템 로그 익스포트 (ELK Stack 연동)
    virtual void export_to_syslog(const SystemMonitoringRecord& record) = 0;

    // 알람 시스템 연동
    virtual void send_alert(const std::string& alert_type,
                          const std::string& message,
                          const std::string& severity) = 0;
};
```

### 5.2 HTTP 모니터링 서버
```cpp
class MonitoringHTTPServer {
private:
    SimplePublisherV2* _publisher;
    std::vector<SimpleSubscriber*> _subscribers;
    MonitoringExporter* _exporter;

public:
    // REST API 엔드포인트
    // GET /api/v1/publisher/status
    // GET /api/v1/subscribers/status
    // GET /api/v1/system/health
    // GET /api/v1/metrics
    // POST /api/v1/alerts/acknowledge

    void start_http_server(int port = 8080);
    void register_publisher(SimplePublisherV2* pub);
    void register_subscriber(SimpleSubscriber* sub);
};
```

## 6. 모니터링 통합 전략

### 6.1 계층화된 모니터링
- **Level 1**: 기본 상태 (연결 수, 시퀀스 번호)
- **Level 2**: 성능 메트릭 (처리량, 지연시간)
- **Level 3**: 상세 진단 (에러 로그, 네트워크 상태)

### 6.2 저장소 분리 전략
- **핫 데이터**: 실시간 상태 (메모리 기반)
- **웜 데이터**: 최근 모니터링 히스토리 (HashMaster)
- **콜드 데이터**: 장기 보관용 (파일/DB)

### 6.3 알람 정책
- 시퀀스 지연 임계값 초과
- 연결 끊김 감지
- 복구 실패 반복
- 시스템 리소스 부족

## 7. 구현 단계별 계획

### Phase 1: 기본 모니터링 데이터 수집
1. `SystemMonitoringRecord`, `SubscriberMonitoringData` 구조체 구현
2. `SequenceStorage` 인터페이스에 모니터링 메소드 추가
3. Publisher/Subscriber에 기본 모니터링 API 추가

### Phase 2: 실시간 상태 수집
1. 주기적 모니터링 스레드 구현
2. 메트릭 수집 및 계산 로직 구현
3. 하트비트 메커니즘 구현

### Phase 3: 외부 시스템 연동
1. HTTP 모니터링 서버 구현
2. Prometheus/Grafana 메트릭 익스포터 구현
3. 알람 시스템 연동

### Phase 4: 고급 분석 및 대시보드
1. 실시간 대시보드 구현
2. 히스토리 분석 및 트렌드 분석
3. 자동 장애 감지 및 복구

## 8. 기대 효과

구현 완료 시 다음이 가능해집니다:

1. **실시간 모니터링**: 웹 대시보드에서 모든 컴포넌트 상태 확인
2. **히스토리 분석**: 과거 성능 트렌드 및 장애 패턴 분석
3. **자동 알람**: 임계값 초과시 즉시 알림
4. **용량 계획**: 시스템 확장 시점 예측
5. **장애 대응**: 빠른 문제 진단 및 해결

## 9. 관련 파일

- `pubsub/SequenceStorage.h`: 모니터링 인터페이스 확장
- `pubsub/SimplePublisherV2.h/.cpp`: Publisher 모니터링 API
- `pubsub/SimpleSubscriber.h/.cpp`: Subscriber 모니터링 API
- `monitoring/`: 새로 생성할 모니터링 전용 디렉토리
  - `MonitoringExporter.h/.cpp`
  - `MonitoringHTTPServer.h/.cpp`
  - `DashboardData.h`

---
*작성일: 2025-09-24*
*작성자: Claude Code Assistant*